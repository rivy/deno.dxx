// spell-checker:ignore (jargon) bikeshed falsey glob globbing truthy vendored ; (js) gmsu imsu msu ; (libs) micromatch picomatch ; (names) Deno SkyPack ; (options) globstar nobrace noquantifiers nocase nullglob ; (people) Roy Ivy III * rivy ; (utils) xargs

// FixME: (repaired by needs tests)[2021-11-01; rivy] fix trailing slash issue and write tests; `e*` => 'eg' but `e*/` => 'e*/' (POSIX is 'eg/')

// FixME: [2021-10-17; rivy] current code returns values with incorrect prefixes (eg, '**/...' has leading SEP, './**/...' is missing leading './')
// !! *** need to re-evaluate prefix handling
// !! *** lots of extended globs aren't matching correctly `.*` should match '.' and '..'; `?(.[^.]|)*` (=> `?(.[!.]^|)*` for Windows b/c of `^` and `|` special characters) should match all files in directory, including dot-files, except '.' and '..'

// FixME: [2021-11-01; rivy] `$path.join` normalizes the path (removing '.' and '..' portions) and converts to platform-specific separators; take the reins and add options to allow user choice instead
// !... * check input string for path separator and translate to that separator for outputs; but allow user selection via an option `{sep: string (null => smart sep, or separator character (take only first))}`

// FixME: [2021-11-01; rivy] many paths are being skipped, especially above the owned user directory (a permissions problem?); check for throws in walk?

// ToDO: review RegExp construction statements to avoid panics where appropriate (explore deno std for possible examples of good handling practices)

// ToDO: review checks for progression in splits => continue to use an assert? what do we guarantee about returned 'token'?

// ToDO: add support for end-of-expansion token (eg, `--#`); all subsequent tokens are passed through in their raw, unexpanded form
//   ... the end-of-expansion token must be in bare unquoted form on the original command line (any end-of-expansion tokens generated by expansion are ignored)

// ref: [bash shell expansion](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_04.html) @@ <https://archive.is/GFMJ1>
// ref: [GNU ~ bash shell expansions](https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html) @@ <https://archive.is/lHgK6>
// ref: [GNU ~ bash quote removal](https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html) @@ <https://archive.is/sAYie>

// ESM conversion refs
// ref: <https://esbuild.github.io/plugins>
// ref: <https://github.com/postui/esm.sh/blob/master/server/build.go>
// ref: <https://github.com/postui/esm.sh>
// ref: <https://esbuild.github.io/plugins/#resolve-results>
// ref: <https://dev.to/ije/introducing-esm-cdn-for-npm-deno-1mpo> // `esm` client?
// ref: <https://github.com/remorses/esbuild-plugins>
// ref: <https://github.com/snowpackjs/rollup-plugin-polyfill-node>
// ref: <https://esbuild.github.io/plugins/#resolve-callbacks>
// ref: <https://www.google.com/search?q=using+esbuild+polyfill&oq=using+esbuild+polyfill&aqs=chrome..69i57.7740j0j1&sourceid=chrome&ie=UTF-8>
// ref: <https://github.com/evanw/esbuild/issues/298>
// ref: <https://github.com/evanw/esbuild/blob/03a33e6e007467d99989ecf82fad61bd928a71aa/CHANGELOG.md#0717>
// ref: <https://stackoverflow.com/questions/64557638/how-to-polyfill-node-core-modules-in-webpack-5>
// ref: <https://www.npmjs.com/package/path-browserify>
// ref: <https://github.com/evanw/esbuild/issues/85>
// ref: <https://stackoverflow.com/questions/61821038/how-to-use-npm-module-in-deno>
// ref: <https://jspm.org/docs/cdn>

import { $fs, $osPaths, $path, assert } from './$deps.ts';

import { walk, walkSync } from './xWalk.ts';

import * as Braces from './xBraces.ts';

export { expand as braceExpand } from './xBraces.ts';

// esm.sh
// import Braces from 'https://cdn.esm.sh/braces@3.0.2';
// import Micromatch from 'https://cdn.esm.sh/micromatch@4.0.2';
// import Picomatch from 'https://esm.sh/picomatch@2.3.0?no-check';
import PicomatchM from 'https://esm.sh/picomatch@2.3.1?no-check'; // '?no-check' is used to avoid failed attempts by esm.sh to import types for 'picomatch'
import PicomatchT from '../@types/picomatch@2.2.1/index.d.ts'; // use locally vendored types
const Picomatch = PicomatchM as typeof PicomatchT;
// esm.sh (un-minimized, readable source)
// import Braces from 'https://cdn.esm.sh/braces@3.0.2?dev';
// import Micromatch from 'https://cdn.esm.sh/micromatch@4.0.2?dev';
// import Picomatch from 'https://cdn.esm.sh/picomatch@2.2.2?dev';

// // jspm.io
// import BracesM from 'https://ga.jspm.io/npm:braces@3.0.2/index.js';
// import MicromatchM from 'https://ga.jspm.io/npm:micromatch@4.0.2/index.js';
// import PicomatchM from 'https://ga.jspm.io/npm:picomatch@2.2.2/index.js';
// jspm.dev
// import * as BracesT from 'https://cdn.jsdelivr.net/gh/DefinitelyTyped/DefinitelyTyped@7121cbff79/types/braces/index.d.ts';
// import * as MicromatchT from 'https://cdn.jsdelivr.net/gh/DefinitelyTyped/DefinitelyTyped@7121cbff79/types/micromatch/index.d.ts';
// import * as PicomatchT from 'https://cdn.jsdelivr.net/gh/DefinitelyTyped/DefinitelyTyped@7121cbff79/types/picomatch/index.d.ts';
// import BracesM from 'https://jspm.dev/npm:braces@3.0.2';
// import MicromatchM from 'https://jspm.dev/npm:micromatch@4.0.2';
// import PicomatchM from 'https://jspm.dev/npm:picomatch@2.3.0';
// const Braces = BracesM as typeof BracesT;
// const Micromatch = MicromatchM as typeof MicromatchT;
// const Picomatch = PicomatchM as typeof PicomatchT; // noSonar ; disable "type assertion not necessary"; needed for correct typings as 'picomatch' develops

// esm.sh (self-hosting)
// * `go install github.com/alephjs/esm.sh` ; `esm.sh.exe --port=8080 --dev` // spell-checker:ignore (name) alephjs
// import Braces from 'http://localhost/braces@3.0.2?bundle';
// import Micromatch from 'http://localhost/micromatch@4.0.2?bundle';
// import Picomatch from 'http://localhost/picomatch@2.2.2?bundle';

// import Braces from 'http://smtp-lan:8080/braces@3.0.2?bundle';
// import Micromatch from 'http://smtp-lan:8080/micromatch@4.0.2?bundle';
// import Picomatch from 'http://smtp-lan:8080/picomatch@2.2.2?bundle';

// * skypack imports fail due to missing polyfills
// import Braces from 'https://cdn.skypack.dev/braces@3.0.2?dts';
// import Micromatch from 'https://cdn.skypack.dev/micromatch@4.0.2?dts';
// import Picomatch from 'https://cdn.skypack.dev/picomatch@2.2.2?dts';

const isWinOS = Deno.build.os === 'windows';

export const envNullglob = () => {
	const e = Deno.env.get('nullglob') || '';
	// console.warn('envNullglob()', { e });
	if (e.match(/^(0|f|false|no|off)?$/)) {
		// console.warn(`${e} matched falsey`);
		return false;
	}
	return true;
};
// console.warn({ envNullglob: envNullglob() });

// ToDO: add ArgsOptions = {
//    endExpansionToken (default == '-+'; setting this also sets partialExpansion to true)
//    partialExpansionAllowed (default == false)
//    }

// const endExpansionToken = '-~'; // ToDO: bikeshed best alternative for an end-of-expansion token
// const endExpansionToken = '-.'; // ToDO: bikeshed best alternative for an end-of-expansion token
const endExpansionToken = '-+'; // ToDO: bikeshed best alternative for an end-of-expansion token
// const endExpansionToken = '--++'; // ToDO: bikeshed best alternative for an end-of-expansion token
// const endExpansionToken = '---'; // ToDO: bikeshed best alternative for an end-of-expansion token

// const globStarAsReS = '(?!\\.)(?=.)[^\\\\/]*?';
// const globDoubleStarAsReS =
// 	'(?:^|[\\\\/]|(?:(?:(?!(?:^|[\\\\/])\\.).)*?)[\\\\/])(?!\\.)(?=.)[^\\\\/]*?';

export const portablePathSepReS = '[\\/]';

// const GlobStringBrand: unique symbol = Symbol();
/** A glob pattern, in string form, meant to be fed to globbing functions.
-	*branded* to mimic a nominal type (and for better Intellisense handling).
*/
export type GlobString = string & { '#brand': 'GlobString' };
// const RegexStringBrand: unique symbol = Symbol();
/** A regular expression pattern, in string form, meant to be fed to `RegExp(...)`.
-	*branded* to mimic a nominal type (and for better Intellisense handling).
*/
export type RegexString = string & { '#brand': 'RegexString' };

/** Double quote character */
const DQ = '"';
/** Single quote character */
const SQ = "'";
/** Regex pattern matching a double-quoted string (unbalanced at end-of-line is allowed). */
const DQStringReS: RegexString = `${DQ}[^${DQ}]*(?:${DQ}|$)` as RegexString;
/** Regex pattern matching a single-quoted string (unbalanced at end-of-line is allowed). */
const SQStringReS: RegexString = `${SQ}[^${SQ}]*(?:${SQ}|$)` as RegexString;
// /** double-quoted string (quote balance is required) */
// const DQStringStrictReS = '"[^"]*"';
// /** single-quoted string (quote balance is required) */
// const SQStringStrictReS = "'[^']*'";

/** ANSIC-style string (eg, `$'...'`) */
const ANSICStringReS: RegexString = '[$]' + SQStringReS as RegexString;

const globChars = ['?', '*', '[', ']'];
/** Regex pattern matching any glob character */
const globCharsReS: RegexString = globChars.map((c) => '\\' + c).join('|') as RegexString;

// const pathSepRe = /[\\/]/;
// const sep = $path.sep;
// const sepReS = $path.SEP_PATTERN;
/** Regex character set matching the path separator character set */
const pathSepReS: RegexString = `[\\\\\\/]` as RegexString;

/** Regex pattern for double or single quote character */
const QReS: RegexString = `[${DQ}${SQ}]` as RegexString;
// /** Regex pattern matching a character which is NON-glob.  */
// const nonGlobReS = `(?:(?!${globCharsReS}).)`;
// /** Regex pattern matching a character which is NON-glob and NON-(single or double)-quote.  */
// const nonGlobQReS = `(?:(?!${globCharsReS}|${QReS}).)`;
/** Regex pattern matching a character which is NON-glob, NON-(single or double)-quote, and NON-separator.  */
const nonGlobQSepReS: RegexString = `(?:(?!${globCharsReS}|${QReS}|${pathSepReS}).)` as RegexString;

/** Regex pattern matching a non-(double or single)-quote character. */
const cNonQReS = `(?:(?!${QReS}).)`;
/** Regex pattern matching a non-(double or single)-quote, non-whitespace character. */
const cNonQWSReS = `(?:(?!${QReS}|\\s).)`;

export function splitByBareWSo(s: string): Array<string> {
	// parse string into tokens separated by unquoted-whitespace
	// * supports both single and double quotes
	// * no character escape sequences are recognized
	// * unbalanced quotes are allowed (parsed as if EOL is a completing quote)
	const arr: Array<string> = [];
	s = s.replace(/^\s+/msu, ''); // trim leading whitespace
	// console.warn('xArgs.splitByBareWSo()', { s });
	const tokenRe = new RegExp(`^((?:${DQStringReS}|${SQStringReS}|${cNonQWSReS}+)*)(.*$)`, 'msu');
	while (s) {
		const m = s.match(tokenRe);
		if (m) {
			arr.push(m[1]);
			s = m[2] ? m[2].replace(/^\s+/msu, '') : ''; // trim leading whitespace
		} else {
			s = '';
		}
		// console.warn({ _: 'splitByBareWSo()', s, m, arr });
	}
	return arr;
}

/** Group of regular expressions matching specific parts of a "word" (or token). */
const WordRxs = {
	/** RegExp matching a bare (non-quoted) portion of a word.
	- `(tokenFragment)(bareWS)?(restOfString)` */
	bareWS: new RegExp(`^((?:${DQStringReS}|${SQStringReS}|${cNonQWSReS}+))(\\s+)?(.*$)`, 'msu'),
	/** RegExp matching a (single or double) quoted portion of a word.
	- `(tokenFragment)(restOfString)` */
	quoteBasic: new RegExp(`^((?:${DQStringReS}|${SQStringReS}|${cNonQReS}+))(.*?$)`, 'msu'),
	/** RegExp matching a (single or double *or __ANSI-C__*) quoted portion of a word.
	- `(tokenFragment)(restOfString)` */
	quote: new RegExp(
		`^((?:${ANSICStringReS}|${DQStringReS}|${SQStringReS}|${cNonQReS}+))(.*?$)`,
		'msu',
	),
};

export function shiftCLTextWord(
	s: string,
	options: { autoQuote: boolean } = { autoQuote: true },
): [string, string] {
	// parse string into a token + restOfString separated by unquoted-whitespace
	// * supports both single and double quotes
	// * no character escape sequences are recognized
	// * unbalanced quotes are allowed (parsed as if EOL is a completing quote)
	const { autoQuote } = options;
	const initialS = s;
	// console.warn('xArgs.shiftCLTextWord()', { s, options, initialS });
	s = s.replace(/^\s+/msu, ''); // trim leading whitespace // ToDO: remove? allow leading WS in first token?
	const wordRx = WordRxs.bareWS; // == (tokenFragment)(bareWS)?(restOfString)
	let foundFullToken = false;
	let token = '';
	while (s && !foundFullToken) {
		const m = s.match(wordRx);
		if (m) {
			let matchStr = m[1];
			if (matchStr.length > 0) {
				const firstChar = matchStr[0];
				if (firstChar === DQ || firstChar === SQ) {
					// "..." or '...'
					if (autoQuote && matchStr[matchStr.length - 1] !== firstChar) {
						matchStr += firstChar;
					}
					// } else if ((matchStr.length > 1) && firstChar === '$' && matchStr[1] === SQ) {
					// 	// $'...'
					// 	matchStr = decodeANSIC(matchStr.split(SQ)[1]);
				}
			}
			token += matchStr;
			s = m[3] ? m[3].replace(/^\s+/msu, '') : ''; // trim leading whitespace
			if (m[2] || !s) {
				foundFullToken = true;
			}
		} else {
			// possible branch?
			foundFullToken = true;
			token += s;
			s = '';
		}
	}
	assert(!initialS || (s !== initialS), 'non-progression of `shiftCLTextWord()`'); // assert progress has been made o/w panic
	return [token, s];
}

export function wordSplitCLTextByShift(
	s: string,
	options: { autoQuote: boolean } = { autoQuote: true },
): Array<string> {
	// parse string into tokens separated by unquoted-whitespace
	// * supports both single and double quotes
	// * no character escape sequences are recognized
	// * unbalanced quotes are allowed (parsed as if EOL is a completing quote)
	// * note: by bench-test, this (`wordSplitCLTextByShift()`) is approx 10% slower than `wordSplitCLText()` (~3.3µs vs ~2.9µs)
	const arr: Array<string> = [];
	s = s.replace(/^\s+/msu, ''); // trim leading whitespace
	while (s) {
		const [token, restOfString] = shiftCLTextWord(s, options);
		arr.push(token);
		assert(s !== restOfString, 'non-progression of `wordSplitCLTextByShift()`'); // assert progress has been made o/w panic
		s = restOfString;
	}
	return arr;
}

export function wordSplitCLText(
	s: string,
	options: { autoQuote: boolean } = { autoQuote: true },
): Array<string> {
	// parse string into tokens (aka words) separated by unquoted-whitespace
	// * supports both single and double quotes
	// * no character escape sequences are recognized
	// * unbalanced quotes are allowed (parsed as if EOL is a completing quote)
	const { autoQuote } = options;
	const arr: Array<string> = [];
	s = s.replace(/^\s+/msu, ''); // trim leading whitespace
	// console.warn('xArgs.wordSplitCLText()', { s });
	const wordRe = WordRxs.bareWS; // == (tokenFragment)(bareWS)?(restOfString)
	let text = '';
	while (s) {
		const m = s.match(wordRe);
		if (m) {
			let matchStr = m[1];
			if (matchStr.length > 0) {
				const firstChar = matchStr[0];
				if (firstChar === DQ || firstChar === SQ) {
					// "..." or '...'
					if (autoQuote && matchStr[matchStr.length - 1] !== firstChar) {
						matchStr += firstChar;
					}
					// } else if ((matchStr.length > 1) && firstChar === '$' && matchStr[1] === SQ) {
					// 	// $'...'
					// 	matchStr = decodeANSIC(matchStr.split(SQ)[1]);
				}
			}
			text += matchStr;
			s = m[3] ? m[3].replace(/^\s+/msu, '') : ''; // trim leading whitespace
			if (m[2] || !s) {
				arr.push(text);
				text = '';
			}
		} else {
			// possible?
			arr.push(text);
			text = s = '';
		}
	}
	return arr;
}

// spell-checker: ignore ANSIC

// ref: <https://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript>
// ref: <https://stackoverflow.com/questions/17191945/conversion-between-utf-8-arraybuffer-and-string/22373135>
// ref: <https://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript/22373061>
// ref: <https://flaviocopes.com/javascript-unicode> @@ <https://archive.is/hZMLw>
// ref: <https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html> @@ <https://archive.is/SeXLl>
// ref: <https://en.wikipedia.org/wiki/Escape_sequences_in_C> @@ <https://archive.is/8OPBU>
// ref: <https://kevin.burke.dev/kevin/node-js-string-encoding> @@ <https://archive.is/JGXQg>
// ref: <https://mathiasbynens.be/notes/javascript-unicode> @@ <https://archive.is/Uqi1y>
// ref: <https://mathiasbynens.be/notes/javascript-encoding> @@ <https://archive.is/yNnof>
// ref: <http://speakingjs.com/es5/ch24.html> @@ <https://archive.is/X7YJf>
// ref: <https://www.whoishostingthis.com/resources/ascii> @@ <https://archive.is/92sIR>
const ANSICDecodeTable: Record<string, string> = {};
ANSICDecodeTable['\\'] = '\\';
ANSICDecodeTable["'"] = "'";
ANSICDecodeTable['?'] = '?';
ANSICDecodeTable['a'] = '\x07';
ANSICDecodeTable['b'] = '\b';
ANSICDecodeTable['e'] = '\x1b';
ANSICDecodeTable['E'] = '\x1b'; // bash-ism
ANSICDecodeTable['f'] = '\f';
ANSICDecodeTable['n'] = '\n';
ANSICDecodeTable['r'] = '\r';
ANSICDecodeTable['t'] = '\t';
ANSICDecodeTable['v'] = '\v';
// control characters
{
	let i;
	const baseCharCode = '@'.charCodeAt(0);
	for (i = 0; i <= 0x1f; i++) {
		const iToChar = String.fromCharCode(baseCharCode + i);
		ANSICDecodeTable['c' + iToChar.toLowerCase()] = ANSICDecodeTable['c' + iToChar.toUpperCase()] =
			String.fromCharCode(i);
	}
	ANSICDecodeTable['c?'] = '\x7f';
}

// console.warn('xArgs', { ANSICDecodeTable });

function decodeANSIC(s: string) {
	// * return value is always a valid UTF-8 string (lossy with 'Replacement Character's, as needed)
	// console.warn('xArgs.decodeANSIC()', { s });
	// note: sequential hex/octal codes are collected as one and then decoded as a UTF-8 string (lossy method using 'Replacement Character')
	s = s.replace(
		// spell-checker:disable-next
		/\\([abeEfnrtv]|c.|u[0-9a-fA-F]{1,4}|U[0-9a-fA-F]{1,8}|(?:(?:[0-7]{1,3}|x[0-9a-fA-F]{2})(?:\\([0-7]{1,3}|x[0-9a-fA-F]{2}))*))/gmsu,
		(escapeString) => {
			const escapeCode = escapeString.slice(1);
			const escapeCodeType = escapeCode[0];
			let decoded = '';
			if ((escapeCodeType === 'u') || (escapeCodeType === 'U')) {
				const decodedCode = parseInt(escapeCode.slice(1), 16);
				try {
					decoded = String.fromCodePoint(decodedCode);
				} catch (_) {
					decoded = String.fromCharCode(decodedCode);
				}
			} else if ((escapeCodeType === 'x') || (escapeCodeType.match(/[0-9]/))) {
				// hex (`\x..`) or octal (`\nnn`) sequences may result in a non-UTF string
				// * all sequential escapes are collected as one into a Uint8Array and the converted to UTF-8 via a no-error lossy conversion
				const splitSep = '\\';
				const codesText = escapeString.split(splitSep).slice(1);
				const codesRaw = codesText.map((codeText) => {
					const parseBase = (codeText[0] === 'x') ? 16 : 8;
					return parseInt(codeText[0] === 'x' ? codeText.slice(1) : codeText, parseBase);
				});
				const codes = new Uint8Array(codesRaw);
				decoded = new TextDecoder().decode(codes);
				// console.warn('xArgs.decodeANSIC', { escapeString, codesText, codesRaw, codes, decoded });
			} else {
				decoded = ANSICDecodeTable[escapeCode.toLowerCase()];
			}

			// console.warn('xArgs.decodeANSIC()', {
			// 	escapeString,
			// 	escapeCode,
			// 	escapeCodeType,
			// 	decoded: decoded,
			// });

			return decoded ? decoded : escapeString;
		},
	);
	return s;
}

export function reQuote(s: string) {
	// re-quote string to protect from later re-expansion
	const specialChars = ['*', '?', '{', '}', '[', ']', "'", '"', '$', '<', '>', '|', '&'];
	const hasSpecialChar = specialChars.find((c) => s.includes(c));
	const hasWhiteSpace = s.match(/\s/msu);
	if (hasSpecialChar || hasWhiteSpace) {
		s = isWinOS ? ('"' + s.replaceAll('"', '""""') + '"') : ("'" + s.replaceAll("'", '"\'"') + "'");
	}
	return s;
}

export function shellDeQuote(s: string) {
	// de-code/quote quoted string
	// * supports both single and double quotes
	// * supports decoding ANSI-C quotes (ie, $'...')
	// * no character escape sequences are recognized
	// * unbalanced quotes are allowed (parsed as if EOL is a completing quote)
	// console.warn('xArgs.shellDeQuote()', { s });
	const tokenRe = WordRxs.quote; // == (ANSIC/DQ/SQ/non-Q-tokenFragment)(tailOfString)
	let text = '';
	while (s) {
		const m = s.match(tokenRe);
		if (m) {
			// console.warn('xArgs.shellDeQuote()', { m });
			let matchStr = m[1];
			if (matchStr.length > 0) {
				if (matchStr[0] === DQ || matchStr[0] === SQ) {
					// "..." or '...'
					const qChar = matchStr[0];
					const spl = matchStr.split(qChar);
					matchStr = spl[1];
				} else if ((matchStr.length > 1) && matchStr[0] === '$' && matchStr[1] === SQ) {
					// $'...'
					const spl = matchStr.split(SQ);
					// console.warn('xArgs.shellDeQuote()', { s, matchStr, spl });
					matchStr = decodeANSIC(spl[1]);
				}
			}
			text += matchStr;
			s = m[2]; // (tailOfString)
		} else {
			text += s;
			s = '';
		}
	}
	return text;
}

export function tildeExpand(s: string): string {
	// tilde expand a string
	// * any leading whitespace is removed
	// ToDO?: handle `~USERNAME` for other users
	s = s.replace(/^\s+/msu, ''); // trim leading whitespace
	// console.warn('xArgs.tildeExpand()', { s });
	// const sepReS = portablePathSepReS;
	const username = Deno.env.get('USER') || Deno.env.get('USERNAME') || '';
	const usernameReS = username.replace(/(.)/gmsu, '\\$1');
	const caseSensitive = !isWinOS;
	const re = new RegExp(
		`^\s*(~(?:${usernameReS})?)(${pathSepReS}|$)(.*)`,
		caseSensitive ? '' : 'i',
	);
	const m = s.match(re);
	if (m) {
		s = $osPaths.home() + (m[2] ? m[2] : '') + (m[3] ? m[3] : '');
	}
	return s;
}

export function subShellExpand(_s: string): Array<string> {
	throw '`subShellExpand()`: unimplemented';
}

function escapeRegExp(s: string) {
	return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

export type GlobExpandOptions = { nullglob: boolean };
export async function* globExpandIter(
	glob: GlobString,
	options: GlobExpandOptions = { nullglob: envNullglob() },
): AsyncIterableIterator<string> {
	// filename (glob) expansion
	const caseSensitive = !isWinOS;
	const globHasTrailingSep = glob.match(new RegExp($path.SEP_PATTERN.source + '$'));
	const globWithoutTrailingSep = glob.replace(new RegExp($path.SEP_PATTERN.source + '$'), '');
	const parsed = parseGlob(globWithoutTrailingSep);

	// console.warn('xArgs.globExpandIter()', { parsed });

	let found = false;
	if (parsed.glob.length > 0) {
		// * a resolved path will have no trailing SEP unless it is the root path (ref: <https://nodejs.org/api/path.html#path_path_resolve_paths>)
		const resolvedPrefix = pathToOS($path.win32.resolve(parsed.prefix)); // `pathToOS($path.win32.resolve(...))` is used as it handles both back and forward slashes and then converts to OS-preferred path style
		// console.warn('xArgs.globExpandIter()', { parsed, resolvedPrefix });
		if (await $fs.exists(resolvedPrefix)) {
			const resolvedHasTrailingSep = resolvedPrefix.match(/[\\/]$/msu);
			const initialGlobstar = parsed.globScan.glob.startsWith('**/');
			// console.warn({ prefix: parsed.prefix, resolvedPrefix, initialGlobstar });
			// FixME: make sure that Sync version *uses the same algorithm*
			// FixME: [2021-10-07; rivy] revise this *working* code to increase logical clarity
			// * initial globstar requires a prefix *w/o* trailing SEP in the final RegExp
			// * o/w the prefix should have a trailing SEP in the final RegExp
			// ToDO: add tests for the correct outputs
			// normalize prefix to have a trailing separator
			// ToDO: convert to use of $path.SEP_PATTERN
			// const normalizedPrefix = resolvedPrefix +
			// 	(resolvedPrefix.endsWith('/') || resolvedPrefix.endsWith('\\') ? '' : $path.SEP);
			// // ToDO: convert to use of $path.SEP_PATTERN
			// const globEscapedPrefix = escapeRegExp(normalizedPrefix).replace(/\\\\|\//g, '[\\\\/]');
			// FixME: [2021-10-07; rivy] this *assumes* that resolvedPrefix will NOT have a trailing SEP
			// * parsed.globScan.glob == "normalized" POSIX-style glob expression
			const globEscapedPrefix =
				(escapeRegExp(
					resolvedPrefix + ((resolvedHasTrailingSep || initialGlobstar)
						? ''
						: $path.SEP),
				))
					.replace(/\\\\|\//g, '[\\\\/]');
			// some paths are resolved to paths with trailing separators (eg, root or network paths) and other are not
			// const trailingSep = globEscapedPrefix.endsWith('[\\\\/]');
			const maxDepth = (parsed // deno-lint-ignore no-explicit-any
			.globScanTokens as unknown as any)
				.reduce((acc: number, value: { value: string; depth: number; isGlob: boolean }) =>
					acc + (value.isGlob ? value.depth : 0), 0);
			// FixME: [2021-11-27; rivy] combining 'i' and 'u' flags slows regexp matching by an order of magnitude+; evaluate whether 'u' is needed here
			const re = new RegExp(
				'^' + globEscapedPrefix + parsed.globAsReS + '$',
				caseSensitive
					? 'msu'
					: 'imsu',
			);
			// console.warn('xArgs.globExpandIter()', {
			// 	resolvedPrefix,
			// 	resolvedHasTrailingSep,
			// 	globEscapedPrefix,
			// 	maxDepth,
			// 	re,
			// });
			// note: `walk/walkSync` match re is compared to the full path during the walk
			const walkIt = walk(resolvedPrefix, { match: [re], maxDepth: maxDepth ? maxDepth : 1 });
			for await (const e of walkIt) {
				const p = ((globHasTrailingSep && e.isDirectory) || !globHasTrailingSep) &&
					e.path.replace(
						new RegExp(
							'^' + globEscapedPrefix + ((!resolvedHasTrailingSep && initialGlobstar)
								? '[\\\\/]'
								: ''),
						),
						'',
					);
				// console.warn({ e, p });
				if (p) {
					found = true;
					// using string interpolation concatenation to preserve prefix path separators (avoiding `$path.join`)
					yield `${parsed.prefix}${p}` + (globHasTrailingSep ? $path.SEP : ''); // FixME: [2022-01-25; rivy] interpolated string concatenation is used instead of `$path.join`; b/c `$path.join` normalizes the path (removing '.' and '..' portions) and converts to platform-specific separators; take the reins and add options to allow user choice instead
				}
			}
		}
	}

	if (!parsed.glob || (!found && !options.nullglob)) {
		yield glob;
	}
}

export function* globExpandIterSync(
	glob: GlobString,
	options: GlobExpandOptions = { nullglob: envNullglob() },
) {
	// filename (glob) expansion
	const caseSensitive = !isWinOS;
	const globHasTrailingSep = glob.match(new RegExp($path.SEP_PATTERN.source + '$'));
	const globWithoutTrailingSep = glob.replace(new RegExp($path.SEP_PATTERN.source + '$'), '');
	const parsed = parseGlob(globWithoutTrailingSep);

	// console.warn('xArgs.globExpandIterSync()', {
	// 	glob,
	// 	globHasTrailingSep,
	// 	globWithoutTrailingSep,
	// 	parsed,
	// });

	let found = false;
	if (parsed.glob.length > 0) {
		// * a resolved path will have no trailing SEP unless it is the root path (ref: <https://nodejs.org/api/path.html#path_path_resolve_paths>)
		const resolvedPrefix = pathToOS($path.win32.resolve(parsed.prefix)); // `pathToOS($path.win32.resolve(...))` is used as it handles both back and forward slashes and then converts to OS-preferred path style
		// console.warn('xArgs.globExpandIter()', { parsed, resolvedPrefix });
		if ($fs.existsSync(resolvedPrefix)) {
			const resolvedHasTrailingSep = resolvedPrefix.match(/[\\/]$/msu);
			const initialGlobstar = parsed.globScan.glob.startsWith('**/');
			const globEscapedPrefix =
				(escapeRegExp(
					resolvedPrefix + ((resolvedHasTrailingSep || initialGlobstar)
						? ''
						: $path.SEP),
				))
					.replace(/\\\\|\//g, '[\\\\/]');
			// some paths are resolved to paths with trailing separators (eg, root or network paths) and other are not
			// const trailingSep = globEscapedPrefix.endsWith('[\\\\/]');
			const maxDepth = (parsed // deno-lint-ignore no-explicit-any
			.globScanTokens as unknown as any)
				.reduce((acc: number, value: { value: string; depth: number; isGlob: boolean }) =>
					acc + (value.isGlob ? value.depth : 0), 0);
			// FixME: [2021-11-27; rivy] combining 'i' and 'u' flags slows regexp matching by an order of magnitude (10-20x); evaluate whether 'u' is needed here
			const re = new RegExp(
				'^' + globEscapedPrefix + parsed.globAsReS + '$',
				caseSensitive
					? 'msu'
					: 'imsu',
			);
			// note: `walk/walkSync` match re is compared to the full path during the walk
			const walkIt = walkSync(resolvedPrefix, { match: [re], maxDepth: maxDepth ? maxDepth : 1 });
			for (const e of walkIt) {
				const p = ((globHasTrailingSep && e.isDirectory) || !globHasTrailingSep) &&
					e.path.replace(
						new RegExp(
							'^' + globEscapedPrefix + ((!resolvedHasTrailingSep && initialGlobstar)
								? '[\\\\/]'
								: ''),
						),
						'',
					);
				if (p) {
					found = true;
					// using string interpolation concatenation to preserve prefix path separators (avoiding `$path.join`)
					yield `${parsed.prefix}${p}` + (globHasTrailingSep ? $path.SEP : ''); // FixME: [2022-01-25; rivy] interpolated string concatenation is used instead of `$path.join`; b/c `$path.join` normalizes the path (removing '.' and '..' portions) and converts to platform-specific separators; take the reins and add options to allow user choice instead
				}
			}
		}
	}

	if (!parsed.glob || (!found && !options.nullglob)) {
		yield glob;
	}
}

export async function globExpandAsync(
	glob: GlobString,
	options: GlobExpandOptions = { nullglob: envNullglob() },
) {
	// filename (glob) expansion
	const arr: string[] = [];
	for await (const e of globExpandIter(glob, options)) {
		arr.push(e);
	}
	return arr;
}
export function globExpandSync(
	glob: GlobString,
	options: GlobExpandOptions = { nullglob: envNullglob() },
) {
	// filename (glob) expansion
	const arr: string[] = [];
	for (const e of globExpandIterSync(glob, options)) {
		arr.push(e);
	}
	return arr;
}
export function globExpand(
	glob: GlobString,
	options: GlobExpandOptions = { nullglob: envNullglob() },
) {
	// filename (glob) expansion
	return globExpandAsync(glob, options);
}

// ToDO: [2022-01-25; rivy] move to '$shared'
function pathToOS(p: string) {
	return isWinOS ? pathToWinOS(p) : pathToPOSIX(p);
}
function pathToPOSIX(p: string) {
	// ToDO: convert to use of $path.SEP_PATTERN
	return p.replace(/\\/g, '/');
}
function pathToWinOS(p: string) {
	return p.replace(/\//g, '\\');
}

// ToDO: handle long paths, "\\?\...", and UNC paths
// ref: [1][MSDN - Windows: Naming Files, Paths, and Namespaces] http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx @@ https://archive.today/DgH7i

// parseGlob()
/** parse glob into a non-glob prefix and glob stem portion
 */
export function parseGlob(s: string) {
	// options.os => undefined (aka portable), 'windows', 'posix'/'linux'
	const options: { os?: string } = {};
	let prefix = '';
	let glob = '';

	const caseSensitive = !isWinOS;

	// console.warn('xArgs.parseNonGlobPathPrefix()', { globCharsReS, SEP: $path.SEP, SEP_PATTERN: $path.SEP_PATTERN });

	// for 'windows' or portable, strip any leading `\\?\` as a prefix
	if (!options.os || options.os === 'windows') {
		const m = s.match(/^(\\\\\?\\)(.*)/);
		if (m) {
			prefix = m[1] ? m[1] : '';
			s = m[2] ? m[2] : '';
		}
	}

	const re = new RegExp(
		`^((?:${DQStringReS}|${SQStringReS}|${nonGlobQSepReS}+)*(?:${pathSepReS}+|$))(.*$)`,
	);
	// console.warn('xArgs.parseGlob()', { re });
	while (s) {
		const m = s.match(re);
		// console.warn('xArgs.parseGlob()', { s, m });
		if (m) {
			prefix += m[1] ? m[1] : '';
			glob = m[2];
			s = m[1] && m[2] ? m[2] : '';
		} else {
			glob = s || '';
			s = '';
		}
		// console.warn('xArgs.parseGlob()', { prefix, glob });
	}

	const pJoin = $path.join(pathToOS(prefix), glob);
	const pJoinToPosix = pathToPOSIX(pJoin);
	// console.warn('xArgs.parseGlob()',
	//  {
	// 	prefix,
	// 	glob,
	// 	pJoin,
	// 	pJoinToPosix,
	// 	pJoinParsed: $path.parse(pJoin),
	// 	pJoinToPosixParsed: $path.parse(pJoinToPosix),
	// });
	const globAsReS = glob && globToReS(glob);
	// console.warn('xArgs.parseGlob()', { globAsReS });
	// const globScan: any = Picomatch.scan($path.join(prefix, glob), {
	// console.warn('xArgs.parseGlob()', { prefix, glob, pathJoin: $path.posix.join(prefix, glob) });
	// * 'picomatch' has incomplete typing => ignore no-explicit-any
	// deno-lint-ignore no-explicit-any
	const globScan: any = Picomatch.scan(pJoinToPosix, {
		windows: true,
		dot: false,
		nobrace: true,
		noquantifiers: true,
		posix: true,
		nocase: !caseSensitive,
		tokens: true,
		parts: true,
	});
	const globScanTokens = globScan.tokens;
	const globScanSlashes = globScan.slashes;
	const globScanParts = globScan.parts;
	// const globParsed = Picomatch.scan(glob, {
	// 	windows: true,
	// 	dot: false,
	// 	nobrace: true,
	// 	noquantifiers: true,
	// 	posix: true,
	// 	nocase: !caseSensitive,
	// 	tokens: true,
	// });
	// const globParsedTokens = ((globParsed as unknown) as any).tokens;
	// const globParsedParts = ((globParsed as unknown) as any).parts;

	return {
		prefix,
		glob,
		globAsReS,
		globScan,
		globScanTokens,
		globScanSlashes,
		globScanParts,
		// globParsed,
		// globParsedTokens,
		// globParsedParts,
	};
}

export function globToReS(s: string) {
	const caseSensitive = !isWinOS;
	const tokenRe = new RegExp(`^((?:${DQStringReS}|${SQStringReS}|${cNonQReS}+))(.*?$)`, '');
	let text = '';
	while (s) {
		const m = s.match(tokenRe);
		if (m) {
			let matchStr = m[1];
			if (matchStr.length > 0) {
				const firstChar = matchStr[0];
				if (firstChar === DQ || firstChar === SQ) {
					// "..." or '...' => de-quote and `[.]` escape any special characters
					const spl = matchStr.split(firstChar);
					matchStr = spl[1];
					// * `[.]` escape glob characters
					matchStr = matchStr.replace(/([?*\[\]])/gmsu, '[$1]');
				}
			}
			text += matchStr;
			s = m[2];
		}
	}
	// convert PATTERN to POSIX-path-style by replacing all backslashes with slashes (backslash is *not* used as an escape)
	text = text.replace(/\\/g, '/');

	// console.warn('xArgs.globToReS()', { text });

	// windows = true => match backslash and slash as path separators
	const parsed = Picomatch.parse(text, {
		windows: true,
		dot: false,
		literalBrackets: false,
		posix: true,
		nocase: !caseSensitive,
	});
	// console.warn('xArgs.globToReS()', { parsed });
	// deno-lint-ignore no-explicit-any
	return ((parsed as unknown) as any).output as string;
}

export type ArgsOptions = { nullglob: boolean };

// `shellExpandAsync()`
/** 'shell'-expand argument string(s).

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
- Character escape sequences are not recognized/supported.
- Brace expansion is fully implemented (including nested braces and ["brace bomb"](https://github.com/micromatch/braces/blob/master/README.md#brace-matching-pitfalls) protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Promise for an iterable array of argument expansions (possibly empty)
@example
```js
const expansion: string[] = await shellExpandAsync('{.,}*'); // or `shellExpand(['{.,}*', './src/file_{1..10..2}_*.ts'])`
```
*/
export async function shellExpandAsync(
	args: string | string[],
	options: ArgsOptions = { nullglob: envNullglob() },
) {
	const arr = Array.isArray(args) ? args : [args];
	const arrOut: string[] = [];
	// console.warn('xArgs.shellExpand()', { options, arr });
	for (const e of arr) {
		for (const x of [e].flatMap(Braces.expand).map(tildeExpand)) {
			arrOut.push(...await globExpandAsync(x as GlobString, options));
		}
	}

	return arrOut;
}

// `shellExpandSync()`
/** 'shell'-expand argument string(s)

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
- Character escape sequences are not recognized/supported.
- Brace expansion is fully implemented (including nested braces and ["brace bomb"](https://github.com/micromatch/braces/blob/master/README.md#brace-matching-pitfalls) protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Iterable array of argument expansions (possibly empty)
@example
```js
const expansion: string[] = shellExpandSync('{.,}*'); // or `shellExpandSync(['{.,}*', './src/file_{1..10..2}_*.ts'])`
```
*/
export function shellExpandSync(
	args: string | string[],
	options: ArgsOptions = { nullglob: envNullglob() },
) {
	const arr = Array.isArray(args) ? args : [args];
	// console.warn('xArgs.shellExpandSync()', { options, arr });
	return arr.flatMap(Braces.expand).map(tildeExpand).flatMap((e) =>
		globExpandSync(e as GlobString, options)
	);
}

// `shellExpand()`
/** 'shell'-expand argument string(s).

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
- Character escape sequences are not recognized/supported.
- Brace expansion is fully implemented (including nested braces and ["brace bomb"](https://github.com/micromatch/braces/blob/master/README.md#brace-matching-pitfalls) protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Promise for an iterable array of argument expansions (possibly empty)
@example
```js
const expansion: string[] = await shellExpandAsync('{.,}*'); // or `shellExpand(['{.,}*', './src/file_{1..10..2}_*.ts'])`
```
*/
export function shellExpand(
	args: string | string[],
	options: ArgsOptions = { nullglob: envNullglob() },
) {
	return shellExpandAsync(args, options);
}

//$ `args()` (aka `argsAsync()`)
/** Parse (if needed) and 'shell'-expand argument text string(s).

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
- ANSI-C strings (eg, $'...') are supported and expanded; otherwise, no character escape sequences are recognized.
- Brace expansion is fully implemented (including nested braces and ["brace bomb"](https://github.com/micromatch/braces/blob/master/README.md#brace-matching-pitfalls) protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Promise for an iterable array of argument expansions (possibly empty)
@example
```ts
const argsText = '{.,}* "text string" ./src/file_{1..10..2}_*.ts';
const expansion: string[] = await args(argsText);
```
*/
export function args(
	argsText: string | string[],
	options: ArgsOptions = { nullglob: envNullglob() },
) {
	return argsAsync(argsText, options);
}

//$ `argsAsync()`
//$from `args()` -@example
/** Parse (if needed) and 'shell'-expand argument text string(s).

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
- ANSI-C strings (eg, $'...') are supported and expanded; otherwise, no character escape sequences are recognized.
- Brace expansion is fully implemented (including nested braces and ["brace bomb"](https://github.com/micromatch/braces/blob/master/README.md#brace-matching-pitfalls) protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Promise for an iterable array of argument expansions (possibly empty)
@example
```ts
const argsText = '{.,}* "text string" ./src/file_{1..10..2}_*.ts';
const expansion: string[] = await argsAsync(argsText);
```
*/
export async function argsAsync(
	argsText: string | string[],
	options: ArgsOptions = { nullglob: envNullglob() },
) {
	const arr = Array.isArray(argsText) ? argsText : wordSplitCLText(argsText);
	const idx = arr.findIndex((v) => v === endExpansionToken);
	const expand = arr.length ? (arr.slice(0, idx < 0 ? undefined : (idx + 1))) : [];
	const raw = (arr.length && (idx > 0) && (idx < arr.length)) ? arr.slice(idx + 1) : [];
	// console.warn('xArgs.args()', { arr, idx, expand, raw });
	return (await shellExpand(expand, options)).map(shellDeQuote).concat(raw);
}

//$ `argsSync()`
//$from `args()`
/** Parse (if needed) and 'shell'-expand argument string(s).

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
- ANSI-C strings (eg, $'...') are supported and expanded; otherwise, no character escape sequences are recognized.
- Brace expansion is fully implemented (including nested braces and ["brace bomb"](https://github.com/micromatch/braces/blob/master/README.md#brace-matching-pitfalls) protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@$from `args()`
@returns Iterable array of argument expansions (possibly empty)
@example
```ts
const argsText = '{.,}* "text string" ./src/file_{1..10..2}_*.ts';
const expansion: string[] = args(argsText);
```
*/
export function argsSync(
	argsText: string | string[],
	options: ArgsOptions = { nullglob: envNullglob() },
) {
	const arr = Array.isArray(argsText) ? argsText : wordSplitCLText(argsText);
	const idx = arr.findIndex((v) => v === endExpansionToken);
	const expand = arr.length ? (arr.slice(0, idx < 0 ? undefined : (idx + 1))) : [];
	const raw = (arr.length && (idx > 0) && (idx < arr.length)) ? arr.slice(idx + 1) : [];
	// console.warn('xArgs.args()', { arr, idx, expand, raw });
	return shellExpandSync(expand, options).map(shellDeQuote).concat(raw);
}

export type ArgIncrementAsync = {
	arg: string;
	tailOfArgExpansion: AsyncIterableIterator<string>[];
	tailOfArgsText: string;
};
export type ArgIncrementSync = {
	arg: string;
	tailOfArgExpansion: string[][];
	tailOfArgsText: string;
};

// `argsItAsync`
/** Incrementally parse and 'shell'-expand argument text; returning a lazy iterator of ArgIncrementSync's.

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
  Otherwise, no character escape sequences are recognized.
- Brace expansion is fully implemented (including nested braces and "brace bomb" protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Async iterator of expansions with corresponding remaining argument string (ie, `[arg, restOfArgS]`)
@example
```js
// eg, for `deno`, `dxr`, `env`, `xargs`, ...
const argsText = '--processOptions ... targetExecutable {.,}* "text*string" ./src/file_{1..10..2}_*.ts';
const argIt = argsItAsync(argsText);
const processArgs = [];
let targetArgsText = '';
let options = null;
for await (const [arg, restOfArgsText] of argIt) {
	processArgs.push(arg);
	options = getOptions(processArgs);
	if (options.targetExecutable) {
		targetArgsText = restOfArgsText;
		break;
	}
}
if (options.targetExecutable) {
	// run `targetExecutable` with `targetArgsText` (un-processed argument text)
}
```
*/
export async function* argsItAsync(
	argsText: string,
	options: ArgsOptions = { nullglob: envNullglob() },
): AsyncIterableIterator<ArgIncrementAsync> {
	let continueExpansions = true;
	while (argsText) {
		let argText = '';
		[argText, argsText] = shiftCLTextWord(argsText);
		if (argText === endExpansionToken) continueExpansions = false;
		const argExpansions = continueExpansions
			? [argText].flatMap(Braces.expand).map(tildeExpand).map((e) =>
				globExpandIter(e as GlobString, options)
			)
			: [(async function* () {
				yield argText;
			})()];
		for (let idx = 0; idx < argExpansions.length; idx++) {
			const argExpansion = argExpansions[idx];
			let current = await argExpansion.next();
			while (!current.done) {
				const next = await argExpansion.next();
				// const tail = [argExpansion]
				yield {
					arg: shellDeQuote(current.value),
					tailOfArgExpansion: [
						...(!next.done
							? [(async function* () {
								yield next.value;
								for await (const e of argExpansion) yield e;
							})()]
							: []),
						...argExpansions.slice(idx + 1),
					],
					tailOfArgsText: argsText,
				};
				current = next;
			}
		}
	}
}

// `argsItSync`
/** Incrementally parse and 'shell'-expand argument text; returning a lazy iterator of ArgIncrementSync's.

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
  Otherwise, no character escape sequences are recognized.
- Brace expansion is fully implemented (including nested braces and "brace bomb" protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Async iterator of expansions with corresponding remaining argument string (ie, `[arg, restOfArgS]`)
@example
```js
// eg, for `deno`, `dxr`, `env`, `xargs`, ...
const argsText = '--processOptions ... targetExecutable {.,}* "text*string" ./src/file_{1..10..2}_*.ts';
const argIt = argsItSync(argsText);
const processArgs = [];
let targetArgsText = '';
let options = null;
for (const [arg, restOfArgsText] of argIt) {
	processArgs.push(arg);
	options = getOptions(processArgs);
	if (options.targetExecutable) {
		targetArgsText = restOfArgsText;
		break;
	}
}
if (options.targetExecutable) {
	// run `targetExecutable` with `targetArgsText` (un-processed argument text)
}
```
*/
export function* argsItSync(
	argsText: string,
	options: ArgsOptions = { nullglob: envNullglob() },
): IterableIterator<ArgIncrementSync> {
	const continueExpansions = false;
	while (argsText) {
		let argText = '';
		[argText, argsText] = shiftCLTextWord(argsText);
		// if (argText === endExpansionToken) continueExpansions = false;
		const argExpansions = continueExpansions
			? [argText].flatMap(Braces.expand).map(tildeExpand).map((e) =>
				globExpandSync(e as GlobString, options)
			)
			: [[argText]];
		for (let idx = 0; idx < argExpansions.length; idx++) {
			const argExpansion = argExpansions[idx];
			for (let jdx = 0; jdx < argExpansion.length; jdx++) {
				yield {
					arg: shellDeQuote(argExpansion[jdx]),
					tailOfArgExpansion: [argExpansion.slice(jdx + 1), ...argExpansions.slice(idx + 1)],
					tailOfArgsText: argsText,
				};
			}
		}
	}
}

// `argsIt`
/** Incrementally parse and 'shell'-expand argument text; returning a lazy iterator of ArgIncrementAsync.

- Performs `bash`-like expansion (compatible with the Bash v4.3 specification).
- Quotes (single or double) are used to protect braces, tildes, and globs from expansion;
	unbalanced quotes are allowed (and parsed as if completed by the end of the string).
  Otherwise, no character escape sequences are recognized.
- Brace expansion is fully implemented (including nested braces and "brace bomb" protections).
- Glob expansion supports `globstar` and full extended glob syntax.

Uses the [*braces*](https://github.com/micromatch/braces) and [*picomatch*](https://github.com/micromatch/picomatch) JS modules.

@returns Async iterator of expansions with corresponding remaining argument string (ie, `[arg, restOfArgS]`)
@example
```js
// eg, for `deno`, `dxr`, `env`, `xargs`, ...
const argsText = '--processOptions ... targetExecutable {.,}* "text*string" ./src/file_{1..10..2}_*.ts';
const argIt = argsIt(argsText);
const processArgs = [];
let targetArgsText = '';
let options = null;
for await (const [arg, restOfArgsText] of argIt) {
	processArgs.push(arg);
	options = getOptions(processArgs);
	if (options.targetExecutable) {
		targetArgsText = restOfArgsText;
		break;
	}
}
if (options.targetExecutable) {
	// run `targetExecutable` with `targetArgsText` (un-processed argument text)
}
```
*/
export async function* argsIt(
	argsText: string,
	options: ArgsOptions = { nullglob: envNullglob() },
): AsyncIterableIterator<ArgIncrementAsync> {
	for await (const e of argsItAsync(argsText, options)) {
		yield e;
	}
}
