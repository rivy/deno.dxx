/* esm.sh - esbuild bundle(lru-cache@7.18.3) denonext production */
import __Process$ from "node:process";
var k=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,$=typeof AbortController=="function",E=$?AbortController:class{constructor(){this.signal=new j}abort(t=new Error("This operation was aborted")){this.signal.reason=this.signal.reason||t,this.signal.aborted=!0,this.signal.dispatchEvent({type:"abort",target:this.signal})}},H=typeof AbortSignal=="function",N=typeof E.AbortSignal=="function",j=H?AbortSignal:N?E.AbortController:class{constructor(){this.reason=void 0,this.aborted=!1,this._listeners=[]}dispatchEvent(t){t.type==="abort"&&(this.aborted=!0,this.onabort(t),this._listeners.forEach(i=>i(t),this))}onabort(){}addEventListener(t,i){t==="abort"&&this._listeners.push(i)}removeEventListener(t,i){t==="abort"&&(this._listeners=this._listeners.filter(e=>e!==i))}},D=new Set,I=(n,t)=>{let i=`LRU_CACHE_OPTION_${n}`;O(i)&&R(i,`${n} option`,`options.${t}`,L)},W=(n,t)=>{let i=`LRU_CACHE_METHOD_${n}`;if(O(i)){let{prototype:e}=L,{get:s}=Object.getOwnPropertyDescriptor(e,n);R(i,`${n} method`,`cache.${t}()`,s)}},V=(n,t)=>{let i=`LRU_CACHE_PROPERTY_${n}`;if(O(i)){let{prototype:e}=L,{get:s}=Object.getOwnPropertyDescriptor(e,n);R(i,`${n} property`,`cache.${t}`,s)}},U=(...n)=>{typeof __Process$=="object"&&__Process$&&typeof __Process$.emitWarning=="function"?__Process$.emitWarning(...n):console.error(...n)},O=n=>!D.has(n),R=(n,t,i,e)=>{D.add(n);let s=`The ${t} is deprecated. Please use ${i} instead.`;U(s,"DeprecationWarning",n,e)},m=n=>n&&n===Math.floor(n)&&n>0&&isFinite(n),P=n=>m(n)?n<=Math.pow(2,8)?Uint8Array:n<=Math.pow(2,16)?Uint16Array:n<=Math.pow(2,32)?Uint32Array:n<=Number.MAX_SAFE_INTEGER?z:null:null,z=class extends Array{constructor(t){super(t),this.fill(0)}},B=class{constructor(t){if(t===0)return[];let i=P(t);this.heap=new i(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}},L=class n{constructor(t={}){let{max:i=0,ttl:e,ttlResolution:s=1,ttlAutopurge:h,updateAgeOnGet:r,updateAgeOnHas:f,allowStale:p,dispose:c,disposeAfter:l,noDisposeOnSet:u,noUpdateTTL:o,maxSize:d=0,maxEntrySize:y=0,sizeCalculation:g,fetchMethod:a,fetchContext:w,noDeleteOnFetchRejection:b,noDeleteOnStaleGet:_,allowStaleOnFetchRejection:S,allowStaleOnFetchAbort:A,ignoreFetchAbort:v}=t,{length:T,maxAge:F,stale:x}=t instanceof n?{}:t;if(i!==0&&!m(i))throw new TypeError("max option must be a nonnegative integer");let C=i?P(i):Array;if(!C)throw new Error("invalid max value: "+i);if(this.max=i,this.maxSize=d,this.maxEntrySize=y||this.maxSize,this.sizeCalculation=g||T,this.sizeCalculation){if(!this.maxSize&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(this.fetchMethod=a||null,this.fetchMethod&&typeof this.fetchMethod!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.fetchContext=w,!this.fetchMethod&&w!==void 0)throw new TypeError("cannot set fetchContext without fetchMethod");if(this.keyMap=new Map,this.keyList=new Array(i).fill(null),this.valList=new Array(i).fill(null),this.next=new C(i),this.prev=new C(i),this.head=0,this.tail=0,this.free=new B(i),this.initialFill=1,this.size=0,typeof c=="function"&&(this.dispose=c),typeof l=="function"?(this.disposeAfter=l,this.disposed=[]):(this.disposeAfter=null,this.disposed=null),this.noDisposeOnSet=!!u,this.noUpdateTTL=!!o,this.noDeleteOnFetchRejection=!!b,this.allowStaleOnFetchRejection=!!S,this.allowStaleOnFetchAbort=!!A,this.ignoreFetchAbort=!!v,this.maxEntrySize!==0){if(this.maxSize!==0&&!m(this.maxSize))throw new TypeError("maxSize must be a positive integer if specified");if(!m(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.initializeSizeTracking()}if(this.allowStale=!!p||!!x,this.noDeleteOnStaleGet=!!_,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!f,this.ttlResolution=m(s)||s===0?s:1,this.ttlAutopurge=!!h,this.ttl=e||F||0,this.ttl){if(!m(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.initializeTTLTracking()}if(this.max===0&&this.ttl===0&&this.maxSize===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.max&&!this.maxSize){let M="LRU_CACHE_UNBOUNDED";O(M)&&(D.add(M),U("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",M,n))}x&&I("stale","allowStale"),F&&I("maxAge","ttl"),T&&I("length","sizeCalculation")}getRemainingTTL(t){return this.has(t,{updateAgeOnHas:!1})?1/0:0}initializeTTLTracking(){this.ttls=new z(this.max),this.starts=new z(this.max),this.setItemTTL=(e,s,h=k.now())=>{if(this.starts[e]=s!==0?h:0,this.ttls[e]=s,s!==0&&this.ttlAutopurge){let r=setTimeout(()=>{this.isStale(e)&&this.delete(this.keyList[e])},s+1);r.unref&&r.unref()}},this.updateItemAge=e=>{this.starts[e]=this.ttls[e]!==0?k.now():0},this.statusTTL=(e,s)=>{e&&(e.ttl=this.ttls[s],e.start=this.starts[s],e.now=t||i(),e.remainingTTL=e.now+e.ttl-e.start)};let t=0,i=()=>{let e=k.now();if(this.ttlResolution>0){t=e;let s=setTimeout(()=>t=0,this.ttlResolution);s.unref&&s.unref()}return e};this.getRemainingTTL=e=>{let s=this.keyMap.get(e);return s===void 0?0:this.ttls[s]===0||this.starts[s]===0?1/0:this.starts[s]+this.ttls[s]-(t||i())},this.isStale=e=>this.ttls[e]!==0&&this.starts[e]!==0&&(t||i())-this.starts[e]>this.ttls[e]}updateItemAge(t){}statusTTL(t,i){}setItemTTL(t,i,e){}isStale(t){return!1}initializeSizeTracking(){this.calculatedSize=0,this.sizes=new z(this.max),this.removeItemSize=t=>{this.calculatedSize-=this.sizes[t],this.sizes[t]=0},this.requireSize=(t,i,e,s)=>{if(this.isBackgroundFetch(i))return 0;if(!m(e))if(s){if(typeof s!="function")throw new TypeError("sizeCalculation must be a function");if(e=s(i,t),!m(e))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return e},this.addItemSize=(t,i,e)=>{if(this.sizes[t]=i,this.maxSize){let s=this.maxSize-this.sizes[t];for(;this.calculatedSize>s;)this.evict(!0)}this.calculatedSize+=this.sizes[t],e&&(e.entrySize=i,e.totalCalculatedSize=this.calculatedSize)}}removeItemSize(t){}addItemSize(t,i){}requireSize(t,i,e,s){if(e||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache")}*indexes({allowStale:t=this.allowStale}={}){if(this.size)for(let i=this.tail;!(!this.isValidIndex(i)||((t||!this.isStale(i))&&(yield i),i===this.head));)i=this.prev[i]}*rindexes({allowStale:t=this.allowStale}={}){if(this.size)for(let i=this.head;!(!this.isValidIndex(i)||((t||!this.isStale(i))&&(yield i),i===this.tail));)i=this.next[i]}isValidIndex(t){return t!==void 0&&this.keyMap.get(this.keyList[t])===t}*entries(){for(let t of this.indexes())this.valList[t]!==void 0&&this.keyList[t]!==void 0&&!this.isBackgroundFetch(this.valList[t])&&(yield[this.keyList[t],this.valList[t]])}*rentries(){for(let t of this.rindexes())this.valList[t]!==void 0&&this.keyList[t]!==void 0&&!this.isBackgroundFetch(this.valList[t])&&(yield[this.keyList[t],this.valList[t]])}*keys(){for(let t of this.indexes())this.keyList[t]!==void 0&&!this.isBackgroundFetch(this.valList[t])&&(yield this.keyList[t])}*rkeys(){for(let t of this.rindexes())this.keyList[t]!==void 0&&!this.isBackgroundFetch(this.valList[t])&&(yield this.keyList[t])}*values(){for(let t of this.indexes())this.valList[t]!==void 0&&!this.isBackgroundFetch(this.valList[t])&&(yield this.valList[t])}*rvalues(){for(let t of this.rindexes())this.valList[t]!==void 0&&!this.isBackgroundFetch(this.valList[t])&&(yield this.valList[t])}[Symbol.iterator](){return this.entries()}find(t,i){for(let e of this.indexes()){let s=this.valList[e],h=this.isBackgroundFetch(s)?s.__staleWhileFetching:s;if(h!==void 0&&t(h,this.keyList[e],this))return this.get(this.keyList[e],i)}}forEach(t,i=this){for(let e of this.indexes()){let s=this.valList[e],h=this.isBackgroundFetch(s)?s.__staleWhileFetching:s;h!==void 0&&t.call(i,h,this.keyList[e],this)}}rforEach(t,i=this){for(let e of this.rindexes()){let s=this.valList[e],h=this.isBackgroundFetch(s)?s.__staleWhileFetching:s;h!==void 0&&t.call(i,h,this.keyList[e],this)}}get prune(){return W("prune","purgeStale"),this.purgeStale}purgeStale(){let t=!1;for(let i of this.rindexes({allowStale:!0}))this.isStale(i)&&(this.delete(this.keyList[i]),t=!0);return t}dump(){let t=[];for(let i of this.indexes({allowStale:!0})){let e=this.keyList[i],s=this.valList[i],h=this.isBackgroundFetch(s)?s.__staleWhileFetching:s;if(h===void 0)continue;let r={value:h};if(this.ttls){r.ttl=this.ttls[i];let f=k.now()-this.starts[i];r.start=Math.floor(Date.now()-f)}this.sizes&&(r.size=this.sizes[i]),t.unshift([e,r])}return t}load(t){this.clear();for(let[i,e]of t){if(e.start){let s=Date.now()-e.start;e.start=k.now()-s}this.set(i,e.value,e)}}dispose(t,i,e){}set(t,i,{ttl:e=this.ttl,start:s,noDisposeOnSet:h=this.noDisposeOnSet,size:r=0,sizeCalculation:f=this.sizeCalculation,noUpdateTTL:p=this.noUpdateTTL,status:c}={}){if(r=this.requireSize(t,i,r,f),this.maxEntrySize&&r>this.maxEntrySize)return c&&(c.set="miss",c.maxEntrySizeExceeded=!0),this.delete(t),this;let l=this.size===0?void 0:this.keyMap.get(t);if(l===void 0)l=this.newIndex(),this.keyList[l]=t,this.valList[l]=i,this.keyMap.set(t,l),this.next[this.tail]=l,this.prev[l]=this.tail,this.tail=l,this.size++,this.addItemSize(l,r,c),c&&(c.set="add"),p=!1;else{this.moveToTail(l);let u=this.valList[l];if(i!==u){if(this.isBackgroundFetch(u)?u.__abortController.abort(new Error("replaced")):h||(this.dispose(u,t,"set"),this.disposeAfter&&this.disposed.push([u,t,"set"])),this.removeItemSize(l),this.valList[l]=i,this.addItemSize(l,r,c),c){c.set="replace";let o=u&&this.isBackgroundFetch(u)?u.__staleWhileFetching:u;o!==void 0&&(c.oldValue=o)}}else c&&(c.set="update")}if(e!==0&&this.ttl===0&&!this.ttls&&this.initializeTTLTracking(),p||this.setItemTTL(l,e,s),this.statusTTL(c,l),this.disposeAfter)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift());return this}newIndex(){return this.size===0?this.tail:this.size===this.max&&this.max!==0?this.evict(!1):this.free.length!==0?this.free.pop():this.initialFill++}pop(){if(this.size){let t=this.valList[this.head];return this.evict(!0),t}}evict(t){let i=this.head,e=this.keyList[i],s=this.valList[i];return this.isBackgroundFetch(s)?s.__abortController.abort(new Error("evicted")):(this.dispose(s,e,"evict"),this.disposeAfter&&this.disposed.push([s,e,"evict"])),this.removeItemSize(i),t&&(this.keyList[i]=null,this.valList[i]=null,this.free.push(i)),this.head=this.next[i],this.keyMap.delete(e),this.size--,i}has(t,{updateAgeOnHas:i=this.updateAgeOnHas,status:e}={}){let s=this.keyMap.get(t);if(s!==void 0)if(this.isStale(s))e&&(e.has="stale",this.statusTTL(e,s));else return i&&this.updateItemAge(s),e&&(e.has="hit"),this.statusTTL(e,s),!0;else e&&(e.has="miss");return!1}peek(t,{allowStale:i=this.allowStale}={}){let e=this.keyMap.get(t);if(e!==void 0&&(i||!this.isStale(e))){let s=this.valList[e];return this.isBackgroundFetch(s)?s.__staleWhileFetching:s}}backgroundFetch(t,i,e,s){let h=i===void 0?void 0:this.valList[i];if(this.isBackgroundFetch(h))return h;let r=new E;e.signal&&e.signal.addEventListener("abort",()=>r.abort(e.signal.reason));let f={signal:r.signal,options:e,context:s},p=(d,y=!1)=>{let{aborted:g}=r.signal,a=e.ignoreFetchAbort&&d!==void 0;return e.status&&(g&&!y?(e.status.fetchAborted=!0,e.status.fetchError=r.signal.reason,a&&(e.status.fetchAbortIgnored=!0)):e.status.fetchResolved=!0),g&&!a&&!y?l(r.signal.reason):(this.valList[i]===o&&(d===void 0?o.__staleWhileFetching?this.valList[i]=o.__staleWhileFetching:this.delete(t):(e.status&&(e.status.fetchUpdated=!0),this.set(t,d,f.options))),d)},c=d=>(e.status&&(e.status.fetchRejected=!0,e.status.fetchError=d),l(d)),l=d=>{let{aborted:y}=r.signal,g=y&&e.allowStaleOnFetchAbort,a=g||e.allowStaleOnFetchRejection,w=a||e.noDeleteOnFetchRejection;if(this.valList[i]===o&&(!w||o.__staleWhileFetching===void 0?this.delete(t):g||(this.valList[i]=o.__staleWhileFetching)),a)return e.status&&o.__staleWhileFetching!==void 0&&(e.status.returnedStale=!0),o.__staleWhileFetching;if(o.__returned===o)throw d},u=(d,y)=>{this.fetchMethod(t,h,f).then(g=>d(g),y),r.signal.addEventListener("abort",()=>{(!e.ignoreFetchAbort||e.allowStaleOnFetchAbort)&&(d(),e.allowStaleOnFetchAbort&&(d=g=>p(g,!0)))})};e.status&&(e.status.fetchDispatched=!0);let o=new Promise(u).then(p,c);return o.__abortController=r,o.__staleWhileFetching=h,o.__returned=null,i===void 0?(this.set(t,o,{...f.options,status:void 0}),i=this.keyMap.get(t)):this.valList[i]=o,o}isBackgroundFetch(t){return t&&typeof t=="object"&&typeof t.then=="function"&&Object.prototype.hasOwnProperty.call(t,"__staleWhileFetching")&&Object.prototype.hasOwnProperty.call(t,"__returned")&&(t.__returned===t||t.__returned===null)}async fetch(t,{allowStale:i=this.allowStale,updateAgeOnGet:e=this.updateAgeOnGet,noDeleteOnStaleGet:s=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:r=this.noDisposeOnSet,size:f=0,sizeCalculation:p=this.sizeCalculation,noUpdateTTL:c=this.noUpdateTTL,noDeleteOnFetchRejection:l=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:o=this.ignoreFetchAbort,allowStaleOnFetchAbort:d=this.allowStaleOnFetchAbort,fetchContext:y=this.fetchContext,forceRefresh:g=!1,status:a,signal:w}={}){if(!this.fetchMethod)return a&&(a.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:e,noDeleteOnStaleGet:s,status:a});let b={allowStale:i,updateAgeOnGet:e,noDeleteOnStaleGet:s,ttl:h,noDisposeOnSet:r,size:f,sizeCalculation:p,noUpdateTTL:c,noDeleteOnFetchRejection:l,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:d,ignoreFetchAbort:o,status:a,signal:w},_=this.keyMap.get(t);if(_===void 0){a&&(a.fetch="miss");let S=this.backgroundFetch(t,_,b,y);return S.__returned=S}else{let S=this.valList[_];if(this.isBackgroundFetch(S)){let x=i&&S.__staleWhileFetching!==void 0;return a&&(a.fetch="inflight",x&&(a.returnedStale=!0)),x?S.__staleWhileFetching:S.__returned=S}let A=this.isStale(_);if(!g&&!A)return a&&(a.fetch="hit"),this.moveToTail(_),e&&this.updateItemAge(_),this.statusTTL(a,_),S;let v=this.backgroundFetch(t,_,b,y),T=v.__staleWhileFetching!==void 0,F=T&&i;return a&&(a.fetch=T&&A?"stale":"refresh",F&&A&&(a.returnedStale=!0)),F?v.__staleWhileFetching:v.__returned=v}}get(t,{allowStale:i=this.allowStale,updateAgeOnGet:e=this.updateAgeOnGet,noDeleteOnStaleGet:s=this.noDeleteOnStaleGet,status:h}={}){let r=this.keyMap.get(t);if(r!==void 0){let f=this.valList[r],p=this.isBackgroundFetch(f);return this.statusTTL(h,r),this.isStale(r)?(h&&(h.get="stale"),p?(h&&(h.returnedStale=i&&f.__staleWhileFetching!==void 0),i?f.__staleWhileFetching:void 0):(s||this.delete(t),h&&(h.returnedStale=i),i?f:void 0)):(h&&(h.get="hit"),p?f.__staleWhileFetching:(this.moveToTail(r),e&&this.updateItemAge(r),f))}else h&&(h.get="miss")}connect(t,i){this.prev[i]=t,this.next[t]=i}moveToTail(t){t!==this.tail&&(t===this.head?this.head=this.next[t]:this.connect(this.prev[t],this.next[t]),this.connect(this.tail,t),this.tail=t)}get del(){return W("del","delete"),this.delete}delete(t){let i=!1;if(this.size!==0){let e=this.keyMap.get(t);if(e!==void 0)if(i=!0,this.size===1)this.clear();else{this.removeItemSize(e);let s=this.valList[e];this.isBackgroundFetch(s)?s.__abortController.abort(new Error("deleted")):(this.dispose(s,t,"delete"),this.disposeAfter&&this.disposed.push([s,t,"delete"])),this.keyMap.delete(t),this.keyList[e]=null,this.valList[e]=null,e===this.tail?this.tail=this.prev[e]:e===this.head?this.head=this.next[e]:(this.next[this.prev[e]]=this.next[e],this.prev[this.next[e]]=this.prev[e]),this.size--,this.free.push(e)}}if(this.disposed)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift());return i}clear(){for(let t of this.rindexes({allowStale:!0})){let i=this.valList[t];if(this.isBackgroundFetch(i))i.__abortController.abort(new Error("deleted"));else{let e=this.keyList[t];this.dispose(i,e,"delete"),this.disposeAfter&&this.disposed.push([i,e,"delete"])}}if(this.keyMap.clear(),this.valList.fill(null),this.keyList.fill(null),this.ttls&&(this.ttls.fill(0),this.starts.fill(0)),this.sizes&&this.sizes.fill(0),this.head=0,this.tail=0,this.initialFill=1,this.free.length=0,this.calculatedSize=0,this.size=0,this.disposed)for(;this.disposed.length;)this.disposeAfter(...this.disposed.shift())}get reset(){return W("reset","clear"),this.clear}get length(){return V("length","size"),this.size}static get AbortController(){return E}static get AbortSignal(){return j}},Y=L;export{Y as default};
//# sourceMappingURL=lru-cache.mjs.map